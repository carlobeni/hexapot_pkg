Estoy trabajando en un proyecto de ros2 que puede 
- simular el funcionamiento de los algoritmos de navegacion en un entorno de gazebo leyendo senosores simulados y publicando los comandos de movimiento
- correr los algoritmos de navegacion leyendo los comandos publicados por sensores reales conectados a una pi
Los modos posibles son
- free_navigation: navegacion a posiciones aleatorios de lat y long generados cada 5min con algoritmo de campo pontencial
- goal_navigation: navegacion a posiciones dadas de lat y long con algoritmo de campo pontencial
- follow_target: seguimiento de otro robot
- swarm_aggregation: agregacion a conjunto de robots visualizados

Por ende deben haber 10 launchers, uno por cada modo de navegacion en forma simulada o real
Ejemplo 1
ros2 launch hexapod_pkg free_navigation_sim.launch.py
Modo de navegacio: free_navigation (simulado)
Ejemplo 2
ros2 launch hexapod_pkg free_navigation_real.launch.py
Modo de navegacio: free_navigation (real)

y asi con todos los modos

Tengo algunos launchers base cuyos nodos puede usar como codigo base
Este nodo corre todo el entorno de gazebo y lee los sensores simulados
import os

from ament_index_python.packages import get_package_share_directory
import xacro

from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration

from launch_ros.actions import Node

def generate_launch_description():


    # Include the robot_state_publisher launch file, provided by our own package. Force sim time to be enabled
    # !!! MAKE SURE YOU SET THE PACKAGE NAME CORRECTLY !!!

    package_name='hexapod_pkg' #<--- CHANGE ME

    rsp = IncludeLaunchDescription(
                PythonLaunchDescriptionSource([os.path.join(
                    get_package_share_directory(package_name),'launch','rsp.launch.py'
                )]), launch_arguments={'use_sim_time': 'true', 'use_ros2_control': 'true'}.items()
    )

    joystick = IncludeLaunchDescription(
                PythonLaunchDescriptionSource([os.path.join(
                    get_package_share_directory(package_name),'launch','joystick.launch.py'
                )]), launch_arguments={'use_sim_time': 'true'}.items()
    )



    twist_mux_params = os.path.join(get_package_share_directory(package_name),'config','twist_mux.yaml')
    twist_mux = Node(
            package="twist_mux",
            executable="twist_mux",
            parameters=[twist_mux_params, {'use_sim_time': True}],
            remappings=[('/cmd_vel_out','/diff_cont/cmd_vel_unstamped')]
        )
    
    # =====================================================
    # NODOS Y PRELAUNCHERS DE GAZEBO
    # =====================================================

    default_world = os.path.join(
        get_package_share_directory(package_name),
        'worlds',
        'obstacles3.world'
        )    
    
    world = LaunchConfiguration('world')

    world_arg = DeclareLaunchArgument(
        'world',
        default_value=default_world,
        description='World to load'
        )

    # Include the Gazebo launch file, provided by the ros_gz_sim package
    gazebo = IncludeLaunchDescription(
                PythonLaunchDescriptionSource([os.path.join(
                    get_package_share_directory('ros_gz_sim'), 'launch', 'gz_sim.launch.py')]),
                    launch_arguments={'gz_args': ['-r -v4 ', world], 'on_exit_shutdown': 'true'}.items()
             )

    # Run the spawner node from the ros_gz_sim package. The entity name doesn't really matter if you only have a single robot.
    spawn_entity = Node(package='ros_gz_sim', executable='create',
                        arguments=['-topic', 'robot_description',
                                   '-name', 'hexapod_pkg',
                                   '-z', '0.02'],
                        output='screen')

    joint_state_broadcaster_spawner = Node(
        package="controller_manager",
        executable="spawner",
        arguments=["joint_state_broadcaster"],
    )

    joint_trajectory_controller_spawner = Node(
        package="controller_manager",
        executable="spawner",
        arguments=["joint_trajectory_controller"],
    )

    bridge_params = os.path.join(get_package_share_directory(package_name),'config','gz_bridge.yaml')
    ros_gz_bridge = Node(
        package="ros_gz_bridge",
        executable="parameter_bridge",
        arguments=[
            '--ros-args',
            '-p',
            f'config_file:={bridge_params}',
        ]
    )

    ros_gz_image_bridge = Node(
        package="ros_gz_image",
        executable="image_bridge",
        arguments=["/camera/image_raw"]
    )

    # Emula y gestiona el sensor IR de la simulacion
    gz_ir_emulator = Node(
    package='hexapod_pkg',
    executable='gz_ir_emulator.py',
    name='gz_ir_emulator',
    output='screen'
    )

    # Gestiona la cinematica inversa del hexapodo de la simulacion
    # subsbriver topics:
    # pubbrizer topics:
    gz_hexapod_inverse_kinematics = Node(
    package='hexapod_pkg',
    executable='gz_hexapod_inv_kinematics.py',
    name='gz_hexapod_inv_kinematics',
    output='screen'
    )

    # =====================================================
    # NODOS DE GESTION DE LAS SENSORES
    # =====================================================
    # Gestiona el sensor ultrasonico con
    # -1: no detecta nada
    # valor positivo: distancia a la que se le asigna el rango
    # subsbriver topics:
    # pubbrizer topics:
    sensor_ultrasonic = Node(
    package='hexapod_pkg',
    executable='sensor_ultrasonic.py',
    name='sensor_ultrasonic',
    output='screen'
    )

    # =====================================================
    # NODOS DE COMPUTO
    # =====================================================

    # Calcula la posicion del robot respecto a un punto definido
    #empleando unicamente el GPS
    # subsbriver topics:
    # pubbrizer topics:
    compute_gps_to_local_xy = Node(
    package='hexapod_pkg',
    executable='compute_gps_to_local_xy.py',
    name='compute_gps_to_local_xy',
    output='screen',
    )

    # Calcula la posicion de un robot respecto a un punto definido
    #empleando el GPS de la posicion inical, el heading y una 
    #velocidad constante
    # subsbriver topics:
    # pubbrizer topics:
    compute_stimate_xy = Node(
    package='hexapod_pkg',
    executable='compute_stimate_xy.py',
    name='compute_stimate_xy',
    output='screen',
    )

    # Calcula el heading aplicando filtro Kalman
    # subsbriver topics:
    # pubbrizer topics:
    compute_heading = Node(
    package='hexapod_pkg',
    executable='compute_heading.py',
    name='compute_heading',
    output='screen',
    )

    # =====================================================
    # NODOS MANAGER
    # =====================================================
    # In developments

    # Launch them all!
    return LaunchDescription([
        rsp,
        joystick,

        twist_mux,
        world_arg,
        gazebo,
        spawn_entity,
        joint_state_broadcaster_spawner,
        joint_trajectory_controller_spawner,
        ros_gz_bridge,
        ros_gz_image_bridge,
        gz_ir_emulator,
        gz_hexapod_inverse_kinematics,

        sensor_ultrasonic,

        compute_heading,
        compute_gps_to_local_xy,
        compute_stimate_xy,
    ])


#!/usr/bin/env python3

import os

from ament_index_python.packages import get_package_share_directory

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import ExecuteProcess, TimerAction


def generate_launch_description():

    package_name = "hexapod_pkg"

    # =====================================================
    # LIMPIEZA PREVIA
    # =====================================================
    cleanup = ExecuteProcess(
        cmd=[
            "bash", "-c",
            "pkill -f sensors_fast_listener_node.py || true; "
            "pkill -f sensors_reliable_listener_node.py || true; "
            "pkill -f command_talker_node.py || true; "
            "pkill -f monitor_node_pc.py || true; "
            "pkill -f heading_estimator_node.py || true; "
            "pkill -f twist_mux || true"
        ],
        output="screen"
    )

    # =====================================================
    # TWIST_MUX
    # =====================================================
    twist_mux_params = os.path.join(
        get_package_share_directory(package_name),
        "config",
        "twist_mux.yaml"
    )

    twist_mux = Node(
        package="twist_mux",
        executable="twist_mux",
        name="twist_mux",
        output="screen",
        parameters=[
            twist_mux_params,
            {"use_sim_time": False}
        ],
        # üîë salida est√°ndar del mux
        remappings=[
            ("/cmd_vel_out", "/cmd_vel_robot")
        ],
    )

    # =====================================================
    # LAUNCH
    # =====================================================
    return LaunchDescription([

        # ===== LIMPIEZA =====
        cleanup,

        # Espera corta (mantienes tu enfoque)
        TimerAction(
            period=1.0,
            actions=[

                # ===== TWIST MUX =====
                twist_mux,

                # ===== FAST LISTENER =====
                Node(
                    package="hexapod_pkg",
                    executable="dds_sensors_fast_listener.py",
                    name="dds_sensors_fast_listener",
                    output="screen",
                    parameters=[{
                        "qos_reliability": "best_effort",
                        "qos_history": "keep_last",
                        "qos_depth": 10,
                    }],
                ),

                # ===== RELIABLE LISTENER =====
                Node(
                    package="hexapod_pkg",
                    executable="dds_sensors_reliable_listener.py",
                    name="dds_sensors_reliable_listener",
                    output="screen",
                    parameters=[{
                        "qos_reliability": "reliable",
                        "qos_history": "keep_last",
                        "qos_depth": 10,
                    }],
                ),

                # ===== COMMAND TALKER =====
                Node(
                    package="hexapod_pkg",
                    executable="dds_cmd_talker.py",
                    name="dds_cmd_talker",
                    output="screen",
                    parameters=[{
                        "qos_reliability": "reliable",
                        "qos_history": "keep_last",
                        "qos_depth": 10,
                    }],
                ),

                # ===== KEYBOARD TELEOP =====
                Node(
                    package="teleop_twist_keyboard",
                    executable="teleop_twist_keyboard",
                    name="teleop",
                    output="screen",
                    prefix=["xterm -hold -e"],
                    # sin remaps: teleop publica /cmd_vel
                ),

                # =====================================================
                # RELAY: /cmd_vel  ->  /cmd_vel_robot  y  /diff_cont/cmd_vel_unstamped
                # (ESTO ES LO QUE TE FALTABA: copiar datos realmente)
                # =====================================================
                Node(
                    package="hexapod_pkg",
                    executable="cmd_vel_relay_node.py",
                    name="cmd_vel_relay",
                    output="screen",
                    parameters=[{
                        "input_topic": "/cmd_vel",
                        "out_robot_topic": "/cmd_vel_robot",
                        #"out_sim_topic": "/diff_cont/cmd_vel_unstamped",
                    }],
                ),

                # ===== MONITOR =====
                Node(
                    package="hexapod_pkg",
                    executable="dds_monitor_pc.py",
                    name="dds_monitor_pc",
                    output="screen",
                    prefix=["xterm -hold -e"],
                    parameters=[{
                        "qos_reliability": "best_effort",
                        "qos_history": "keep_last",
                        "qos_depth": 10,

                        "monitor_imu_accel": True,
                        "monitor_imu_mag": True,
                        "monitor_imu_compass": True,
                        "monitor_gps": True,
                        "monitor_cmd_serial": True,
                    }],
                ),
            ]
        ),
    ])

Ademas, a fin de faciliar los codigos tengo un hw_config.py donde tengo todas las constantes de los topics que puedes usar, agregar y modificar
import os

# ================= ROS DOMAIN =================
ROS_DOMAIN_ID = 42

def check_domain_id(logger=None):
    env = os.getenv("ROS_DOMAIN_ID")
    msg = (
        f"ROS_DOMAIN_ID={env} (expected {ROS_DOMAIN_ID})"
        if env else
        f"ROS_DOMAIN_ID NOT set (recommended {ROS_DOMAIN_ID})"
    )
    if logger:
        logger.warning(msg)
    else:
        print(msg)

# ================= DDS TOPICS =================
# TOPICS (From Pi)
TOPIC_PI_IMU_GIR_ACC = "/pi/sensor/imu_data" 
TOPIC_PI_IMU_MAG = "/pi/sensor/imu_mag"
TOPIC_PI_GPS = "/pi/sensor/gps_fix"
TOPIC_PI_CAMERA = "/pi/camera/image_raw"
TOPIC_PI_IR1 = "/pi/sensor/IR_measure1"
TOPIC_PI_IR2 = "/pi/sensor/IR_measure2"
TOPIC_PI_ULTRASONIC = "/pi/sensor/ultrasonic_read"
# TOPICS (From Gazebo)
TOPIC_GZ_IMU_GIR_ACC = "/gz/sensor/imu_data"
TOPIC_GZ_IMU_MAG = "/gz/sensor/imu_mag"
TOPIC_GZ_GPS = "/gz/sensor/gps_fix"
TOPIC_GZ_CAMERA = "/gz/camera/image_raw"
TOPIC_GZ_IR1 = "/gz/sensor/IR_measure1"
TOPIC_GZ_IR2 = "/gz/sensor/IR_measure2"
TOPIC_GZ_ULTRASONIC = "/gz/sensor/ultrasonic_read"

# ================= TOPICS (just for PC) =================
TOPIC_MONITOR = "/pc/system/monitor"  
TOPIC_HEADING_COMPASS    = "/pc/internal/heading_mag"     # heading solo magnet√≥metro
TOPIC_HEADING_COMPASS_KALMAN = "/pc/internal/heading_kalman"  # heading fusionado (PC)

# ================= COMMAND =================
TOPIC_CMD_SERIAL_MEGA = "/cmd_serial"
TOPIC_CMD_VEL_ROBOT = "/cmd_vel_robot"
TOPIC_CMD_SERIAL = "/cmd_serial"

